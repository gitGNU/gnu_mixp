<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from mixp.texi on 12 August 2001 -->

<TITLE>Mixp (Guile interface to Expat) manual</TITLE>
</HEAD>
<BODY>
<H1>Mixp (Guile interface to Expat) manual</H1>
<H2>For use with Mixp 0.20010812</H2>
<ADDRESS>Thierry Bézecourt</ADDRESS>
<P>
<P><HR><P>


<H1><A NAME="SEC1" HREF="mixp_toc.html#TOC1">1  Introduction</A></H1>

<P>
Mixp is a Scheme interface to James Clark's expat library. It may be
used to parse XML documents with Guile.

</P>
<P>
If you do not know expat, first have a look at the sample program
See section <A HREF="mixp.html#SEC2">1.1  Sample programs</A>.  Typically, you will create a parser object with
<CODE>expat:parser-create</CODE>, then associate one or more handlers to it
(usually with <CODE>expat:set-element-handler</CODE> and
<CODE>expat:set-character-data-handler</CODE>), then parse the document with
<CODE>expat:parse</CODE> or <CODE>mixp:parse-file</CODE>.  The most
commonly used functions are documented here.  You may guess how others
work from their prototypes.  See also the test programs in the test/
subdirectory of the distribution.

</P>
<P>
If you happen to know expat already, you will find easily what you are
looking for by taking a C expat function name, replacing <CODE>XML_</CODE>
with <CODE>expat:</CODE>, using hyphens instead of capital letters to separate
the words, and searching it in the reference documentation See section <A HREF="mixp.html#SEC7">2  Expat interface</A>.  In most cases, the prototype is the same, modulo the
differences between C and Scheme.

</P>
<P>
Another source of information, maybe more accurate, is expat itself:
expat.html, xmlparse.h, and http://www.jclark.com/xml/expatfaq.html.

</P>
<P>
Another source of information, maybe less accurate, is me (Thierry
Bézecourt &#60;mixp@thbz.org&#62;, or &#60;thbz@free.fr&#62;).

</P>

<UL>
<LI><A HREF="mixp.html#SEC2">Sample programs</A>: Hello, world
<LI><A HREF="mixp.html#SEC3">Loading Mixp</A>: The first lines in a program which uses Mixp
<LI><A HREF="mixp.html#SEC4">Mixp components</A>: Organization of Mixp modules
<LI><A HREF="mixp.html#SEC5">How to...</A>: How to perform common tasks
<LI><A HREF="mixp.html#SEC6">Bugs and suggestions</A>: Contact me
</UL>



<H2><A NAME="SEC2" HREF="mixp_toc.html#TOC2">1.1  Sample programs</A></H2>
<P>
<A NAME="IDX1"></A>

</P>
<P>
The following sample program reads an XML file (provided with the Mixp
distribution), and prints its start and end tags.  You can launch a
Guile shell from the samples/ directory of the distribute, and execute
this code.  Your GUILE_LOAD_PATH variable should contain the directory
in which you installed Mixp (that is, the directory which contains the
xml/ subdirectory).

</P>

<PRE>
(use-modules (xml expat)
             (xml mixp))

;; Create the parser object
(let ((parser (expat:parser-create)))
  ;; Specify callback functions
  (expat:set-element-handler parser
			     (lambda (p name attribs)
			       (display "start ")(display name)(newline))
			     (lambda (p name)
			       (display "end ")(display name)(newline)))
  ;; Parse the file
  (mixp:parse-file parser "REC-xml-19980210.xml"))
</PRE>

<P>
For more information about the Expat interface and handlers, See section <A HREF="mixp.html#SEC7">2  Expat interface</A>.

</P>
<P>
The following sample program builds a hierarchical tree structure from
an XML document which reside in a string.  This tree structure should be
easy to use with traditional Scheme functions.

</P>

<PRE>
(use-modules (xml mixp))

(let ((xml-doc "&#60;foo name='Paul'&#62;&#60;bar&#62;Some text&#60;/bar&#62;&#60;void/&#62;&#60;/foo&#62;"))
  (display (call-with-input-string xml-doc mixp:xml-&#62;tree)))
</PRE>

<P>
Result is :

<PRE>
((element ("foo" (("name" . "Paul")))
	  (element ("bar" ())
		   (character-data "Some text"))
	  (element ("void" ()))))
</PRE>

<P>
For more information about this interface, See section <A HREF="mixp.html#SEC13">3  High-level extensions</A>.

</P>


<H2><A NAME="SEC3" HREF="mixp_toc.html#TOC3">1.2  Loading Mixp</A></H2>
<P>
<A NAME="IDX2"></A>

</P>
<P>
From the Guile shell or from a Guile script, you should type the
following commands before using the Mixp API:

</P>

<PRE>
(use-modules (xml expat))
(use-modules (xml mixp))
</PRE>

<P>
Actually, you may load just <CODE>xml:expat</CODE> if you intend to use only
the raw expat interface (i.e. the functions which name is prefixed by
<CODE>expat:</CODE>, See section <A HREF="mixp.html#SEC7">2  Expat interface</A>.) You need <CODE>xml:mixp</CODE> if
you want to use the extension functions (See section <A HREF="mixp.html#SEC13">3  High-level extensions</A>.)

</P>


<H2><A NAME="SEC4" HREF="mixp_toc.html#TOC4">1.3  Mixp components</A></H2>
<P>
<A NAME="IDX3"></A>

</P>
<P>
Mixp contains two Scheme modules:

</P>

<UL>

<LI>

<STRONG>xml:expat</STRONG> is the low-level interface to expat.  It stays as close
as possible to the expat API, so that someone who already knows expat
will be able to <CODE>xml:expat</CODE> immediately.  All the functions in this
module are prefixed with <CODE>expat:</CODE>.

<LI>

<STRONG>xml:mixp</STRONG> contains additional functions that may be useful.  For
example, if you need to parse an XML file, it will be easier to use
<CODE>mixp:parse-file</CODE> than <CODE>expat:parse</CODE>.  This module may evolve
into a higher-level interface, for example an object-based interface.
All the functions in this module are prefixed with <CODE>mixp:</CODE>.

</UL>

<P>
On another point of view, Mixp contains two files: a shared library,
<CODE>libexpat.so</CODE>, which defines the <CODE>xml:expat</CODE> interface and a
part of the <CODE>xml</CODE> interface, and a Scheme file, <CODE>mixp.scm</CODE>,
which defines other parts of the <CODE>xml:mixp</CODE> interface. Both files
are located in the <CODE>xml</CODE> directory somewhere along your
GUILE_LOAD_PATH.

</P>


<H2><A NAME="SEC5" HREF="mixp_toc.html#TOC5">1.4  How to...</A></H2>

<P>
This section describes a few common tasks which may be solved with Mixp.

</P>

<UL>
<LI>Check that a document is well-formed

Use <CODE>mixp:parse-data</CODE> without specifying a parser. A default one will be
created, and it will do nothing interesting except raising errors if
there is any error in the document:


<PRE>
(call-with-input-string "&#60;doc&#62;&#60;elem&#62;&#60;/elem&#62;" mixp:parse-data)
</PRE>

See section <A HREF="mixp.html#SEC13">3  High-level extensions</A>.

<LI>Retrieve the content of an element

Suppose you want to retrieve the text contained between an opening tag
and the matching closing tag.  You may do that by using an
element-handler and a character-data-handler together.  The following
code will retrieve the text between <CODE>&#60;title&#62;</CODE> and <CODE>&#60;/title</CODE> in
an XML document:


<PRE>
(use-modules (xml expat)
	     (xml mixp))

(let ((parser (expat:parser-create))
      (in-title-p #f) ;; becomes #t inside the tag
      (title ""))     ;; will contain the result
  (expat:set-element-handler parser
     			     (lambda (p name attribs)
                               (if (equal? name "title")
				   (set! in-title-p #t)))
     			     (lambda (p name)
                               (if (equal? name "title")
				   (set! in-title-p #f))))
  (expat:set-character-data-handler parser
				    (lambda (data value)
				      (if (equal? in-title-p #t)
					  (set! title
						(string-append title value)))))
  (mixp:call-with-input-string "&#60;doc&#62;&#60;title&#62;Hello&#60;/title&#62;&#60;/doc&#62;" 
			       parser)
  (display title)(newline))
</PRE>

<LI>Build a tree structure from an XML document

Use <CODE>mixp:xml-&#62;tree</CODE>.


<PRE>
(call-with-input-file "file.xml" mixp:xml-&#62;tree)
</PRE>

See section <A HREF="mixp.html#SEC13">3  High-level extensions</A>.

<LI>Read the external DTD

The following program will read an XML document in "foo.xml", parse
the DTD which may be referenced in the <CODE>DOCTYPE</CODE> declaration and
expand the entities.


<PRE>
(use-modules (xml expat)
	     (xml mixp)
	     (ice-9 format))

(use-syntax (ice-9 syncase))

;; Create the parser object
(let ((parser (expat:parser-create))
      (external-entity-ref-handler
       (lambda (my-parser
		context
		base
		system-id
		public-id)
	 (display (format "Reference to external entity: ~A.\n"
			  system-id))
	 (open-file system-id "r"))))
  
  (expat:set-param-entity-parsing parser
				  'expat:XML_PARAM_ENTITY_PARSING_ALWAYS)
  ;; Specify callback functions
  (expat:set-character-data-handler parser
				    (lambda (p value)
				      (display "Char: ")
				      (display value)
				      (display ".\n")))
  (expat:set-external-entity-ref-handler parser
					 external-entity-ref-handler)
  ;; Parse the file
  (mixp:parse-file parser "foo.xml"))
</PRE>

<LI>Specify handlers to be called in the DTD

You may want to define handlers to be called when Mixp parses the DTD
and finds an element declaration or an attribute list declaration.
Unfortunately, this is not possible, due to limitations in expat.

However, you may try to use the default handler (See section <A HREF="mixp.html#SEC8">2.1  Expat handlers</A>).
If DTD reading is enabled (see the previous item), then the default
handler will be called repeatedly while reading the DTD, and will
receive each time a part of the DTD.  However, there is no guarantee
about what part of the DTD it will receive each time. Building a
representation of the DTD would be possible with the default handler,
but not easy.

</UL>



<H2><A NAME="SEC6" HREF="mixp_toc.html#TOC6">1.5  Bugs and suggestions</A></H2>

<P>
Please send bug reports to me (mixp@thbz.org or thbz@free.fr).  I would also appreciate
feedback about Mixp, and suggestions about what could be improved in the
interface.

</P>


<H1><A NAME="SEC7" HREF="mixp_toc.html#TOC7">2  Expat interface</A></H1>

<P>
This section contains the reference documentation for the expat
interface, i.e the <CODE>xml:expat</CODE> module.

</P>

<UL>
<LI><A HREF="mixp.html#SEC8">Expat handlers</A>: All the available callback functions
<LI><A HREF="mixp.html#SEC9">Other expat functions</A>: Create a parser, parse a string...
<LI><A HREF="mixp.html#SEC10">Encodings</A>: When a document is not ASCII
<LI><A HREF="mixp.html#SEC11">Error handling</A>: How to catch the errors
<LI><A HREF="mixp.html#SEC12">Not implemented</A>: What is not here
</UL>



<H2><A NAME="SEC8" HREF="mixp_toc.html#TOC8">2.1  Expat handlers</A></H2>
<P>
<A NAME="IDX4"></A>
<A NAME="IDX5"></A>

</P>
<P>
Handlers are functions called by the parser at specific points in the
XML document (for example when finding a new tag, or a comment, etc).
This section explains how to specify these handlers, and what their
prototype should be.  

</P>
<P>
Most of the time, the first argument will be <CODE>user-data</CODE>.
<CODE>user-data</CODE> is either a user-specified buffer (see
<CODE>expat:set-user-data</CODE>) or the parser object itself (see
<CODE>expat:use-parser-as-handler-arg</CODE>).

</P>
<P>
<DL>
<DT><U>Function:</U> <B>expat:set-element-handler</B> <I>parser start-handler end-handler</I>
<DD><A NAME="IDX6"></A>
Specify callback functions to be called when an element starts or
end. 

</P>
<P>
<VAR>parser</VAR> is the parser object returned by
<CODE>expat:parser-create</CODE>.

</P>

<P>
<VAR>start-handler</VAR> is a function to be called when an opening tag is found.
This function will be called as follows:

</P>

<PRE>
(start-handler <VAR>user-data</VAR> <VAR>name</VAR> <VAR>attributes</VAR>)
</PRE>

<P>
<VAR>name</VAR> is the tag name.  <VAR>attributes</VAR> is an association list
which contains the attributes with their values.  

</P>
<P>
<VAR>end-handler</VAR> is a function to be called when an closing tag is found
(&#60;foo&#62;).  This function will be called as follows:

</P>

<PRE>
(end-handler <VAR>user-data</VAR> <VAR>name</VAR>)
</PRE>

<P>
The arguments have the same meaning as in the start handler.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> <B>expat:set-character-data-handler</B> <I>parser handler</I>
<DD><A NAME="IDX7"></A>
Called for normal text (i.e outside &#60;&#62; tags).

</P>

<PRE>
(handler <VAR>user-data</VAR> <VAR>value</VAR>)
</PRE>

<P>
<VAR>value</VAR> is the text encoded in UTF-8.

</P>
</DL>

<P>
<DL>
<DT><U>Function:</U> <B>expat:set-processing-instruction-handler</B> <I>parser handler</I>
<DD><A NAME="IDX8"></A>

</P>
<P>
Sets the processing instruction handler, which should have the following
prototype: 

</P>

<PRE>
(handler <VAR>user-data</VAR> <VAR>pi-data</VAR>)
</PRE>

<P>
This handler will be called by Mixp every time it finds a processing
instruction (<CODE>&#60;?  ... ?&#62;</CODE>).

</P>
</DL>

<P>
<DL>
<DT><U>Function:</U> <B>expat:set-comment-handler</B> <I>parser handler</I>
<DD><A NAME="IDX9"></A>

</P>
<P>
Sets the comment handler, which should have the following prototype:

</P>

<PRE>
(handler <VAR>user-data</VAR> <VAR>comment-data</VAR>)
</PRE>

<P>
This handler will be called by Mixp every time it finds a comment
(<CODE>&#60;!-- ... --&#62;</CODE>).

</P>
</DL>

<P>
<DL>
<DT><U>Function:</U> <B>expat:set-cdata-section-handler</B> <I>parser start-handler end-handler</I>
<DD><A NAME="IDX10"></A>

</P>
<P>
Sets the CDATA section handler, which should have the following
prototype:

</P>

<PRE>
(start-handler <VAR>user-data</VAR>)
(end-handler <VAR>user-data</VAR>)
</PRE>

<P>
This handler will be called by Mixp every time it finds a CDATA section
(<CODE>&#60;![CDATA[ ... ]]&#62;</CODE>).
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> <B>expat:set-default-handler</B> <I>parser handler</I>
<DD><A NAME="IDX11"></A>

</P>
<P>
Sets the default handler and also inhibits expansion of internal
entities.  The entity reference will be passed to the default handler.

</P>

<PRE>
(handler <VAR>user-data</VAR> <VAR>string</VAR>)
</PRE>

<P>
The default handler is called for any characters in the XML document for
which there is no applicable handler.  This includes both characters
that are part of markup which is of a kind that is not reported
(comments, markup declarations), or characters that are part of a
construct which could be reported but for which no handler has been
supplied. The characters are passed exactly as they were in the XML
document except that they will be encoded in UTF-8.  Line boundaries are
not normalized.  Note that a byte order mark character is not passed to
the default handler.  There are no guarantees about how characters are
divided between calls to the default handler: for example, a comment
might be split between multiple calls.

</P>
</DL>

<P>
<DL>
<DT><U>Function:</U> <B>expat:set-default-handler-expand</B> <I>parser handler</I>
<DD><A NAME="IDX12"></A>

</P>
<P>
Sets the default handler but does not inhibit expansion of internal
entities.  The entity reference will not be passed to the default
handler.

</P>

<PRE>
(handler <VAR>user-data</VAR> <VAR>string</VAR>)
</PRE>

<P>
See <CODE>expat:set-default-handler</CODE> for a description of the handler.

</P>
</DL>

<P>
<DL>
<DT><U>Function:</U> <B>expat:set-unparsed-entity-decl-handler</B> <I>parser handler</I>
<DD><A NAME="IDX13"></A>

</P>
<P>
Sets the unparsed entity declaration handler, which should have the following
prototype: 

</P>

<PRE>
(handler <VAR>user-data</VAR> <VAR>entity-name</VAR> <VAR>base</VAR> <VAR>system-id</VAR>
<VAR>public-id</VAR> <VAR>notation-name</VAR>)
</PRE>

<P>
The handler is called by Mixp every time it finds a declaration of an
unparsed entity (<SAMP>`&#60;!ENTITY Antarctica SYSTEM
"http://www.antarctica.net" NDATA vrml&#62;'</SAMP>).

</P>
<P>
The <VAR>base</VAR> argument is whatever was set by <CODE>expat:set-base</CODE>.
The <VAR>entity-name</VAR>, <VAR>system-id</VAR> and <VAR>notation-name</VAR> arguments
will never be <CODE>#f</CODE>.  The other arguments may be.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> <B>expat:set-notation-decl-handler</B> <I>parser handler</I>
<DD><A NAME="IDX14"></A>
Called when finding a notation decl (for example <SAMP>`&#60;!NOTATION vrml
PUBLIC "VRML 2"&#62;'</SAMP>).  This function will be called as follows:

</P>

<PRE>
(handler <VAR>user-data</VAR> <VAR>notation-name</VAR> <VAR>base</VAR> <VAR>system-id</VAR>
<VAR>public-id</VAR>)
</PRE>

<P>
The <VAR>base</VAR> argument is whatever was set by
<CODE>expat:set-base</CODE>.  <VAR>notation-name</VAR> will never be <CODE>#f</CODE>.
The other arguments can be.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> <B>expat:set-namespace-decl-handler</B> <I>parser start-handler end-handler</I>
<DD><A NAME="IDX15"></A>

</P>
<P>
Sets the Namespace declaration handler, which should have the following
prototype: 

</P>

<PRE>
(start-namespace-decl-handler <VAR>user-data</VAR> <VAR>prefix</VAR> <VAR>uri</VAR>)
(end-namespace-decl-handler <VAR>user-data</VAR> <VAR>prefix</VAR> <VAR>uri</VAR>)
</PRE>

<P>
When namespace processing is enabled, these are called once for each
namespace declaration. The call to the start and end element handlers
occur between the calls to the start and end namespace declaration
handlers. For an xmlns attribute, prefix will be null.  For an xmlns=""
attribute, uri will be null.

</P>
</DL>

<P>
<DL>
<DT><U>Function:</U> <B>expat:set-not-standalone-handler</B> <I>parser handler</I>
<DD><A NAME="IDX16"></A>

</P>
<P>
Sets the Standalone declartion handler, which should have the following
prototype: 

</P>

<PRE>
(not-standalone-handler <VAR>user-data</VAR>)
</PRE>

<P>
This is called if the document is not standalone (it has an
external subset or a reference to a parameter entity, but does not
have standalone="yes"). If this handler returns 0, then processing
will not continue, and the parser will return a
<CODE>expat:XML_ERROR_NOT_STANDALONE</CODE> error. 
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> <B>expat:set-external-entity-ref-handler</B> <I>parser handler</I>
<DD><A NAME="IDX17"></A>

</P>

<PRE>
(external-entity-ref-handler <VAR>user-data</VAR> <VAR>context</VAR> <VAR>base</VAR>
<VAR>system-id</VAR> <VAR>public-id</VAR>)
</PRE>

<P>
The external entity reference handler is called by Mixp when it finds a
reference to an external entity in the document.  For example, the
<CODE>&#60;!DOCTYPE ...&#62;</CODE> declaration contains an external entity reference
when it specifies an external DTD.  In that case, you should also call
<CODE>(expat:set-param-entity-parsing parser) </CODE>, because you probably
want Mixp to expand the references to entities declared in your DTD.
See See section <A HREF="mixp.html#SEC5">1.4  How to...</A> for an example.

</P>
<P>
The external entity reference handler should return an open port to the
external entity. For example, assuming that <CODE>system-id</CODE> refers to a
relative file path, you may define the handler as follows:

</P>

<PRE>

(lambda (my-parser
	 context
	 base
	 system-id
	 public-id)
  (display (format "Reference to external entity: ~A.\n"
		   system-id))
  (open-file system-id "r"))

</PRE>

<P>
The system identifier is defined by the XML specification as a URI.
Therefore, the example above will only work if you know that the system
id is actually a file path.  You may need to use, for example, a http
library if you want to support URIs which start with "http://".

</P>
<P>
Note that the behaviour of this handler is very different in expat.

</P>
<P>
Also see <CODE>expat:set-external-entity-ref-handler-arg</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> <B>expat:set-unknown-encoding-handler</B> <I>parser handler</I>
<DD><A NAME="IDX18"></A>
Unknown encoding handlers have not been really tested, so they probably
don't work for now.

</P>

<PRE>
(unknown-encoding-handler <VAR>encoding-handler-data</VAR> <VAR>name</VAR>
<VAR>info</VAR>)
</PRE>

</DL>



<H2><A NAME="SEC9" HREF="mixp_toc.html#TOC9">2.2  Other expat functions</A></H2>
<P>
<A NAME="IDX19"></A>

</P>
<P>
<DL>
<DT><U>Function:</U> <B>expat:parser-create</B> <I>encoding</I>
<DD><A NAME="IDX20"></A>
Constructs a new parser; <VAR>encoding</VAR> is the encoding specified by the
external protocol or <CODE>#t</CODE> if there is none specified.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> <B>expat:parser-create-ns</B> <I>encoding namespace-separator</I>
<DD><A NAME="IDX21"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> <B>expat:set-external-entity-ref-handler-arg</B> <I>arg</I>
<DD><A NAME="IDX22"></A>
If a non-nil value for <VAR>arg</VAR> is specified here, then it will be
passed as the first argument to the external entity ref handler instead
of the parser object.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> <B>expat:default-current</B>
<DD><A NAME="IDX23"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> <B>expat:set-user-data</B> <I>parser data</I>
<DD><A NAME="IDX24"></A>
Associates a value to the parser.  This value will be passed as the
<VAR>user-data</VAR> argument to callbacks, unless
<CODE>expat:use-parser-as-handler-arg</CODE> has been called.  This value
can be any Scheme value.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> <B>expat:get-user-data</B> <I>parser</I>
<DD><A NAME="IDX25"></A>
Returns the user data associated with the parser object.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> <B>expat:set-encoding</B> <I>parser encoding</I>
<DD><A NAME="IDX26"></A>
Encoding functions are not really tested for now.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> <B>expat:use-parser-as-handler-arg</B>
<DD><A NAME="IDX27"></A>
Specifies that the user-data argument passed to callbacks should be the
parser object itself.  User data may still be associated to the parser
with <CODE>expat:set-user-data</CODE> and retrieved with
<CODE>expat:get-user-data</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> <B>expat:set-base</B> <I>parser base</I>
<DD><A NAME="IDX28"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> <B>expat:get-base</B> <I>parser</I>
<DD><A NAME="IDX29"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> <B>expat:get-specified-attribute-count</B> <I>parser</I>
<DD><A NAME="IDX30"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> <B>expat:parse</B> <I>parser buffer is-final</I>
<DD><A NAME="IDX31"></A>
Parse some input.  Returns 0 if a fatal error is detected.  In that
case, you should call <CODE>expat:get-error-code</CODE> to obtain more
information.  The last call to <CODE>expat:parse</CODE> must have
<VAR>is-final</VAR> set to <CODE>#t</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> <B>expat:parse-buffer</B> <I>len is-final</I>
<DD><A NAME="IDX32"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> <B>expat:get-error-code</B> <I>parser</I>
<DD><A NAME="IDX33"></A>
Returns the error code associated with the parser.  This function should
be called after <CODE>expat:parse</CODE> has returned 0 (i.e an
error).  The result is a symbol which may have one of the following
values:

</P>

<UL>
<LI>

expat:XML_ERROR_NONE
<LI>

expat:XML_ERROR_NO_MEMORY
<LI>

expat:XML_ERROR_SYNTAX
<LI>

expat:XML_ERROR_NO_ELEMENTS
<LI>

expat:XML_ERROR_INVALID_TOKEN
<LI>

expat:XML_ERROR_UNCLOSED_TOKEN
<LI>

expat:XML_ERROR_PARTIAL_CHAR
<LI>

expat:XML_ERROR_TAG_MISMATCH
<LI>

expat:XML_ERROR_DUPLICATE_ATTRIBUTE
<LI>

expat:XML_ERROR_JUNK_AFTER_DOC_ELEMENT
<LI>

expat:XML_ERROR_PARAM_ENTITY_REF
<LI>

expat:XML_ERROR_UNDEFINED_ENTITY
<LI>

expat:XML_ERROR_RECURSIVE_ENTITY_REF
<LI>

expat:XML_ERROR_ASYNC_ENTITY
<LI>

expat:XML_ERROR_BAD_CHAR_REF
<LI>

expat:XML_ERROR_BINARY_ENTITY_REF
<LI>

expat:XML_ERROR_ATTRIBUTE_EXTERNAL_ENTITY_REF
<LI>

expat:XML_ERROR_MISPLACED_XML_PI
<LI>

expat:XML_ERROR_UNKNOWN_ENCODING
<LI>

expat:XML_ERROR_INCORRECT_ENCODING
<LI>

expat:XML_ERROR_UNCLOSED_CDATA_SECTION
<LI>

expat:XML_ERROR_EXTERNAL_ENTITY_HANDLING
<LI>

expat:XML_ERROR_NOT_STANDALONE
</UL>

<P>
An error message describing the error may be obtained by calling
<CODE>expat:error-string</CODE>.

</P>
</DL>

<P>
<DL>
<DT><U>Function:</U> <B>expat:get-current-byte-count</B> <I>parser</I>
<DD><A NAME="IDX34"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> <B>expat:get-current-line-number</B> <I>parser</I>
<DD><A NAME="IDX35"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> <B>expat:get-current-column-number</B> <I>parser</I>
<DD><A NAME="IDX36"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> <B>expat:get-current-byte-index</B> <I>parser</I>
<DD><A NAME="IDX37"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> <B>expat:error-string</B> <I>code</I>
<DD><A NAME="IDX38"></A>
Returns an error message describing the expat error code defined by
<VAR>code</VAR>.  <VAR>code</VAR> is usually obtained by calling
<CODE>expat:get-error-code</CODE> on the parser object.
</DL>

</P>


<H2><A NAME="SEC10" HREF="mixp_toc.html#TOC10">2.3  Encodings</A></H2>
<P>
<A NAME="IDX39"></A>

</P>
<P>
Expat supports the following encodings : UTF-8, UTF-16, ISO-8859-1,
US-ASCII.

</P>
<P>
The encoding is usually indicated in the first line of an XML file (the
<CODE>&#60;?xml... ?&#62;</CODE> declaration).  But every data you will receive in
your handlers (tag names, attributes, character data...), will be
encoded in UTF-8, whatever the original encoding was.  UTF-8 represents
ASCII characters with no modification, but represents other characters
with multi-byte characters.  In other words, texts with non-ASCII
characters look very strange on most terminals when they're encoded in
UTF-8.  ISO-8859-1 has a better support in standard editors, but is too
euro-centric.

</P>
<P>
The encoding features of expat are not completely supported in Mixp.
Using unknown encoding handlers will not work, or at least I have not
tested that feature.  However, XML documents which encoding (as
specified in the <CODE>&#60;?xml... ?&#62;</CODE> declaration) is supported by expat
should be parsed correctly.  For example, you should get an error if you
parse a document which claims to be US-ASCII but contains 8-bit
characters.

</P>


<H2><A NAME="SEC11" HREF="mixp_toc.html#TOC11">2.4  Error handling</A></H2>

<P>
In the Expat interface, <CODE>expat:parse</CODE> returns 0 when an error is
encountered, i.e when the document is not well-formed.  Then
<CODE>expat:get-error-code</CODE> should be called to retrieve an error code,
as a Scheme symbol, which identifies the error.  The error codes are
listed in the documentation of <CODE>expat:get-error-code</CODE> (See section <A HREF="mixp.html#SEC9">2.2  Other expat functions</A>).

</P>
<P>
The functions in the Mixp extensions use the same error codes, but they
throw them as exceptions instead of returning 0.  The following codes
demonstrates simple error handling with <CODE>mixp:parse-data</CODE> :

</P>

<PRE>
(let ((bad-xml "&#60;doc&#62;dfssfd&#60;/do&#62;"))
  (catch #t
    (lambda ()
      (call-with-input-string bad-xml mixp:parse-data))
    (lambda (key)
      (display "Received an error: ")(display key)(newline))))
</PRE>

<P>
@result{Received an error: expat:XML_ERROR_TAG_MISMATCH}

</P>


<H2><A NAME="SEC12" HREF="mixp_toc.html#TOC12">2.5  Not implemented</A></H2>

<P>
The following function is a part of the expat interface, but it was not
implemented.

</P>
<P>
<DL>
<DT><U>Function:</U> <B>XML_GetBuffer</B>
<DD><A NAME="IDX40"></A>
</DL>

</P>
<P>
You should also read the section about encodings See section <A HREF="mixp.html#SEC10">2.3  Encodings</A>.

</P>


<H1><A NAME="SEC13" HREF="mixp_toc.html#TOC13">3  High-level extensions</A></H1>
<P>
<A NAME="IDX41"></A>

</P>
<P>
The following functions are extensions to the raw expat interface, but I
still don't know exactly what to do here.

</P>
<P>
<DL>
<DT><U>Function:</U> <B>mixp:parse-file</B> <I>parser file</I>
<DD><A NAME="IDX42"></A>
Parses an XML file See section <A HREF="mixp.html#SEC11">2.4  Error handling</A>.
</DL>

</P>

<P>
<DL>
<DT><U>Function:</U> <B>mixp:parse-data</B> <I>port [parser]</I>
<DD><A NAME="IDX43"></A>
Parses XML data coming from <VAR>port</VAR> See section <A HREF="mixp.html#SEC11">2.4  Error handling</A>.  If
<VAR>parser</VAR> is specified, it must be a parser object, and it will be
used to parse the data.  Else a new parser object will be created with
<CODE>expat:parser-create</CODE>, and this procedure will just check that the
document is well-formed.  <VAR>port</VAR> must be an open input port
@xref{Ports,,,guile-ref}.  Parsing will continue until the end of the
port data is reached.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> <B>mixp:call-with-input-string</B> <I>string parser</I>
<DD><A NAME="IDX44"></A>
Parse a string containing an XML document See section <A HREF="mixp.html#SEC11">2.4  Error handling</A>.
<VAR>parser</VAR> should be created with another procedure such as
<CODE>expat:parser-create</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> <B>mixp:call-with-input-file</B> <I>file parser</I>
<DD><A NAME="IDX45"></A>
Parse an XML file See section <A HREF="mixp.html#SEC11">2.4  Error handling</A>.
<VAR>parser</VAR> should be created with another procedure such as
<CODE>expat:parser-create</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> <B>mixp:xml-&#62;list</B> <I>port [parser]</I>
<DD><A NAME="IDX46"></A>
Parses an XML document from port <VAR>port</VAR> and returns a list of XML
nodes.  Uses <VAR>parser</VAR> if specified, else creates a new parser with
<CODE>expat:parser-create</CODE>.  Each XML node is a small list which
describes a part of the XML file.  The first item in that list is a
symbol which value is the node type.  The meaning of the other items
depend upon the node type.  The following node types are supported
(other kind of data in the XML file is ignored):

</P>
<DL COMPACT>

<DT><CODE>start-element</CODE>
<DD>
A start element.  The second item in the node is the tag name, the
third is an alist which represent the attributes.

<DT><CODE>end-element</CODE>
<DD>
An end element.  The second item in the node is the tag name.

<DT><CODE>character-data</CODE>
<DD>
A character data element.  The second item in the node is the
contents of the item.

<DT><CODE>notation-decl</CODE>
<DD>
A notation declaration.  The second, third, fourth and fifth items
in the node are the notation name, the base, the system id and the
public id.

<DT><CODE>entity-decl</CODE>
<DD>
An entity declaration.  Only unparsed entity declarations are supported
here.  The second, third, fourth, fifth and sixth items in the node
are the entity name, the base, the system id, the public id and the
notation name.

</DL>

</DL>

<P>
<DL>
<DT><U>Function:</U> <B>mixp:xml-&#62;tree</B> <I>port [parser]</I>
<DD><A NAME="IDX47"></A>
Returns a tree structure of XML nodes.  See <CODE>mixp:xml-&#62;list</CODE> above
for the arguments, and for the supported node types.  To give an idea of
the tree structure which is supported, let us consider the following
sample XML document.

</P>

<PRE>
&#60;foo name='Paul'&#62;&#60;bar&#62;Some text&#60;/bar&#62;&#60;void/&#62;&#60;/foo&#62;
</PRE>

<P>
For this document, <CODE>mixp:xml-&#62;list</CODE> will return the following list:

</P>

<PRE>
((start-element "foo" (("name" . "Paul")))
 (start-element "bar" ())
 (character-data "Some text")
 (end-element "bar")
 (start-element "void" ())
 (end-element "void")
 (end-element "foo"))
</PRE>

<P>
And this is the data structure produced by <CODE>mixp:xml-&#62;tree</CODE>:

</P>

<PRE>
(element ("foo" (("name" . "Paul")))
	 (element ("bar" ())
		  (character-data "Some text"))
	 (element ("void" ())))
</PRE>

<P>
Hint: use <CODE>call-with-input-file</CODE> or <CODE>call-with-input-string</CODE>
in conjunction with <CODE>mixp:xml-&#62;list</CODE> or <CODE>mixp:xml-&#62;tree</CODE> to
create structured views of XML documents:

</P>

<PRE>
(call-with-input-file "foobar.xml" mixp:xml-&#62;tree)
</PRE>

</DL>

<P>
<DL>
<DT><U>Function:</U> <B>mixp:tree-&#62;list</B> <I>TREE</I>
<DD><A NAME="IDX48"></A>
Transforms a tree, as returned by <CODE>mixp:xml-&#62;tree</CODE>, into a list, as
returned by <CODE>mixp:xml-&#62;list</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> <B>mixp:list-&#62;tree</B> <I>LIST</I>
<DD><A NAME="IDX49"></A>
Transforms a list, as returned by <CODE>mixp:xml-&#62;list</CODE>, into a tree, as
returned by <CODE>mixp:xml-&#62;tree</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> <B>mixp:expat-error-code</B> <I>integer</I>
<DD><A NAME="IDX50"></A>
Returns the Scheme symbol associated with the expat error code
<VAR>integer</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> <B>mixp:parser?</B> <I>arg</I>
<DD><A NAME="IDX51"></A>
Returns <CODE>#t</CODE> if the <VAR>arg</VAR> is a parser object (as created by
<CODE>expat:parser-create</CODE>.
</DL>

</P>


<H1><A NAME="SEC14" HREF="mixp_toc.html#TOC14">Concept index</A></H1>

<P>
<H2>e</H2>
<DIR>
<LI><A HREF="mixp.html#IDX39">encodings</A>
</DIR>
<H2>h</H2>
<DIR>
<LI><A HREF="mixp.html#IDX4">handlers</A>
</DIR>
<H2>l</H2>
<DIR>
<LI><A HREF="mixp.html#IDX2">loading Mixp</A>
</DIR>
<H2>m</H2>
<DIR>
<LI><A HREF="mixp.html#IDX3">mixp components</A>
</DIR>
<H2>s</H2>
<DIR>
<LI><A HREF="mixp.html#IDX1">sample programs</A>
</DIR>
<H2>x</H2>
<DIR>
<LI><A HREF="mixp.html#IDX41">xml: API</A>
<LI><A HREF="mixp.html#IDX5">xml:expat API (handlers)</A>
<LI><A HREF="mixp.html#IDX19">xml:expat API (miscellaneous functions)</A>
</DIR>

</P>


<H1><A NAME="SEC15" HREF="mixp_toc.html#TOC15">Function index</A></H1>

<P>
<H2>e</H2>
<DIR>
<LI><A HREF="mixp.html#IDX23">expat:default-current</A>
<LI><A HREF="mixp.html#IDX38">expat:error-string</A>
<LI><A HREF="mixp.html#IDX29">expat:get-base</A>
<LI><A HREF="mixp.html#IDX34">expat:get-current-byte-count</A>
<LI><A HREF="mixp.html#IDX37">expat:get-current-byte-index</A>
<LI><A HREF="mixp.html#IDX36">expat:get-current-column-number</A>
<LI><A HREF="mixp.html#IDX35">expat:get-current-line-number</A>
<LI><A HREF="mixp.html#IDX33">expat:get-error-code</A>
<LI><A HREF="mixp.html#IDX30">expat:get-specified-attribute-count</A>
<LI><A HREF="mixp.html#IDX25">expat:get-user-data</A>
<LI><A HREF="mixp.html#IDX31">expat:parse</A>
<LI><A HREF="mixp.html#IDX32">expat:parse-buffer</A>
<LI><A HREF="mixp.html#IDX20">expat:parser-create</A>
<LI><A HREF="mixp.html#IDX21">expat:parser-create-ns</A>
<LI><A HREF="mixp.html#IDX28">expat:set-base</A>
<LI><A HREF="mixp.html#IDX10">expat:set-cdata-section-handler</A>
<LI><A HREF="mixp.html#IDX7">expat:set-character-data-handler</A>
<LI><A HREF="mixp.html#IDX9">expat:set-comment-handler</A>
<LI><A HREF="mixp.html#IDX11">expat:set-default-handler</A>
<LI><A HREF="mixp.html#IDX12">expat:set-default-handler-expand</A>
<LI><A HREF="mixp.html#IDX6">expat:set-element-handler</A>
<LI><A HREF="mixp.html#IDX26">expat:set-encoding</A>
<LI><A HREF="mixp.html#IDX17">expat:set-external-entity-ref-handler</A>
<LI><A HREF="mixp.html#IDX22">expat:set-external-entity-ref-handler-arg</A>
<LI><A HREF="mixp.html#IDX15">expat:set-namespace-decl-handler</A>
<LI><A HREF="mixp.html#IDX16">expat:set-not-standalone-handler</A>
<LI><A HREF="mixp.html#IDX14">expat:set-notation-decl-handler</A>
<LI><A HREF="mixp.html#IDX8">expat:set-processing-instruction-handler</A>
<LI><A HREF="mixp.html#IDX18">expat:set-unknown-encoding-handler</A>
<LI><A HREF="mixp.html#IDX13">expat:set-unparsed-entity-decl-handler</A>
<LI><A HREF="mixp.html#IDX24">expat:set-user-data</A>
<LI><A HREF="mixp.html#IDX27">expat:use-parser-as-handler-arg</A>
</DIR>
<H2>m</H2>
<DIR>
<LI><A HREF="mixp.html#IDX45">mixp:call-with-input-file</A>
<LI><A HREF="mixp.html#IDX44">mixp:call-with-input-string</A>
<LI><A HREF="mixp.html#IDX50">mixp:expat-error-code</A>
<LI><A HREF="mixp.html#IDX49">mixp:list-&#62;tree</A>
<LI><A HREF="mixp.html#IDX43">mixp:parse-data</A>
<LI><A HREF="mixp.html#IDX42">mixp:parse-file</A>
<LI><A HREF="mixp.html#IDX51">mixp:parser?</A>
<LI><A HREF="mixp.html#IDX48">mixp:tree-&#62;list</A>
<LI><A HREF="mixp.html#IDX46">mixp:xml-&#62;list</A>
<LI><A HREF="mixp.html#IDX47">mixp:xml-&#62;tree</A>
</DIR>
<H2>x</H2>
<DIR>
<LI><A HREF="mixp.html#IDX40">XML_GetBuffer</A>
</DIR>

</P>
<P><HR><P>
This document was generated on 12 August 2001 using the
<A HREF="http://wwwcn.cern.ch/dci/texi2html/">texi2html</A>
translator version 1.51.</P>
</BODY>
</HTML>
